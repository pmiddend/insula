* Wichtige Links

- Zwei Fixes für raycastvehicle: http://www.bulletphysics.org/Bullet/phpBB3/viewtopic.php?f=9&t=2047&hilit=rolling+friction
- Frustum/Occlusion culling: http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?f=9&t=3896
- Vehicles in Bullet

* Kurzzeitvorgehen

- physics::object bekommt ein neues Attribut "visible" mit Getter und Setter
- physics::world bekommt eine dbvtBroadphase verpasst
- physics::world bekommt update_visibility, was zunächst die Frustum
  Planes aus der Perspektivmatrix der Kamera extrahiert.
- Dann wird die Schleife aus Bullet ausgeführt und vom broadphaseproxy
  zum body zum object gegangen und dort die Visibility entsprechend
  gesetzt
					
* Aktivitäten
** TODO Nebel
1. Im Pixelshader:
#+BEGIN_SRC emacs-c++-mode
const float LOG2 = 1.442695;
float z = gl_FragCoord.z / gl_FragCoord.w;
float fogFactor = exp2( -gl_Fog.density * 
				   gl_Fog.density * 
				   z * 
				   z * 
				   LOG2 );
fogFactor = clamp(fogFactor, 0.0, 1.0);

gl_FragColor = mix(gl_Fog.color, finalColor, fogFactor );
#+END_SRC

2. Oder doch lieber im Vertexshader, siehe [[http://www.ozone3d.net/tutorials/glsl_fog/p03.php][hier]]:

	"Fremde" Methode:

	1. Berechne gl_Position, nehme davon die Länge =n= (?)
	2. Berechne: =faktor = exp2(-dichte^2 * n^2 *1.442695)=, clampe
		 zwischen 0 und 1, gebe an PS weiter
	3. Berechne =frag_color = mix(fog_color,final_color,fog_factor)=
	
	"Eigene" Methode:
	
	1. Gebe Augenpunkt als uniform mit.
  2. Berechne Abstand Augenpunkt und aktueller Vertex
	3. Berechne =faktor = exp2(-dichte^2 * abstand^2 *1.442695)=, gebe an PS weiter
	4. Mache dasselbe wie bei der fremden Methode.

** TODO Terraingenerierung
** TODO Partikelsystem
- Ein Partikel hat eine Position und eine Lebenszeit
** TODO Shadow Maps [0/5]
*** TODO Neues uniform-System aufsetzen
*** TODO Teste orthografische Projektion aus Sicht der Sonne
*** TODO Setze das Rendern der Shadowmap auf
- Hierzu muss orthografisch projiziert werden aus sich der Sonne
  (Position?)
- Der Vertexshader sollte nur projizieren
- Der Fragmentshader sollte nur einen float rausschreiben, die Tiefe
  des Fragments
- Die Szene muss in eine Textur gerendert werden
*** TODO Per Kommandozeile die Tiefentextur in eine Datei schreiben
*** TODO Den eigentlichen Tiefenalgorithmus implementieren


- Der Heightmap-Vertexshader brauch dazu die mvp-Matrix des Lichtrenderns.
- Für jeden Vertex v werden zwei Größen berechnet: 
	1. vl = mvp_light * v
	2. vp = mvp * v
- Gib vp und vl an den Fragmentshader weiter
- Berechne aus vl die Texturkoordinate in der Shadowmap (selbe Technik
  wie beim Wasser)
- Vergleiche den z-Wert von vp mit dem z-Wert in der Shadowmap, setze
  entsprechend die Pixel
** TODO Physik, Fahrzeuge [6/12]
*** TODO world muss mehr RAII kriegen
*** TODO Max_speed einbauen
"cap speed spaceship" bei google eingeben und das so umsetzen
*** TODO Friction einbauen
*** TODO wheel_info übertragen wie in stk (beide Räder aufm Boden)
*** TODO Steering-Increment einbauen
*** TODO Eigener Raytest?
Damit ist gemeint, dass man height_map::height_for_point nutzt, um den
Raytest beim Terrain zu machen (könnte genauer sein)
** TODO Sounds [0/1]
*** TODO Looping von Musik fixen
Man kann bei Streamingsounds loop einstellen, das funzt aber nicht richtig
** TODO Neues Fontsystem
Ziele:

Man will Farben und Stile (fett, kursiv etc.) unterbringen sowie
verschiedene Größen, das alles steuerbar mit einer kleinen DSEL etwa
wie folgt:

#+begin_src c++
draw_text(
  font_collection,
	size(15) >> color(black) >> "foo" >> (bold >> "bar") 
    >> italics >> size(20) >> "baz");
#+end_src

Man muss sich hier implizit auf ttf beschränken, weil andere
Fontformate vermutlich bold/italics etc. anders modellieren. Eine
=font_collection= muss eine Sammlung von geladenen ttf-Fonts sein
ausgesucht nach:

- Größe
- Stil

In etwa so:

#+begin_src c++
font_collection fonts(
  // Normal
  "default.ttf",
	// Bold
  optional<string>(),
	// Italics,
	"default_it.ttf",
	make_container<size_container>(15)(20)(25));
#+end_src

** TODO Diverses [22/30]
*** TODO cout/cerr zu Konsole weiterleiten
		 CLOSED: [2010-08-03 Tue 20:44]
*** TODO Besseres attribute/uniform-System
1. Funktion T -> glsl-Typ Diese Funktion sollte z.B vector<float/double,N>
   erkennen und vecN draus machen. 
2. Funktion vf::format -> string, die z.B. ausgibt: "in vec3 position; in vec2
   texcoord;" 
3. Definiere Datenstruktur "uniform", die enthaelt "name, typ_string, const"
4. Definiere Funktion "[uniform] -> string", die Zeilen der Form "uniform
   <typ_string> <name>" oder "const <typ_string> <name>" generiert, je nachdem,
   wie das const-Flag gesetzt ist
5. Erweitere Shaderklasse, sodass sie "[uniform]" bekommt und im Vertex- und im
	 Fragmentshader den String $$$uniforms$$$ durch die Liste der Uniforms
	 ersetzt. Ausserdem muesste die Klasse das Vertexformat kennen und daraus den
	 in 2 genannten String definieren. Der wird im Vertexshader durch
	 $$$inputs$$$ ersetzt.
		 CLOSED: [2010-08-14 Sat 18:32]
Wieso ist die Farbe ganz unten nicht korrekt, wenn man einen weniger
detailreichen Skydome erzeugt?
*** TODO Textur tst spiegelverkehrt
		 CLOSED: [2010-08-21 Sat 17:06]
*** TODO physics von model abkoppeln

Erstelle eine Funktion, die eine shape aus einem sge::model::object,
einem Skalierungsfaktor und einer model_approximation erstellt.

*** TODO graphics::stats erweitern
Man könnte die Stats verallgemeinern: Ein "stat" ist eine textuelle
Informationseinheit (z.B. Geschwindigkeit des Vehikels), die scoped
beim "stats"-Objekt eingetragen werden kann. Details muss man sich
noch überlegen.
*** TODO random_flat_point erweitern
*** TODO height_map/calculate_point etc. dokumentieren und ggf. verbessern
*** TODO Musiklautstärke muss einstellbar sein
*** TODO foldl in gameover durch accumulate ersetzen
*** TODO vehicle::speed_kmh muss relativ zu forward sein
*** TODO shape_from_model erweitern
*** TODO gizmo in math verfrachten
*** TODO config.po wegmachen
In config.json Sektion "command-line", in der nur String-Optionen
reinkommen, po-Parser kopieren
