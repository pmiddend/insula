* Aktivitäten
** DONE Kamera
	 CLOSED: [2010-07-28 Wed 21:46]
*** DONE Winkel-Extraktion aus [[http://www.google.com/url?sa=t&source=web&cd=3&ved=0CCUQFjAC&url=http%3A%2F%2Fwww.gregslabaugh.name%2Fpublications%2Feuler.pdf&ei=5BNPTIbkB5rQ4wax7IiCCA&usg=AFQjCNGgP_-68fHn3TvPlqwAomC3TZV4fw][diesem]] Paper umsetzen (in fcppt-Funktion packen?)
		 CLOSED: [2010-07-28 Wed 18:53]
*** DONE 3-Vektor-Ansatz
		 CLOSED: [2010-07-28 Wed 21:46]
**** DONE 
		 CLOSED: [2010-07-28 Wed 19:24]

Definiere Right:=(1,0,0) und Forward:=(0,0,1). Finde heraus, ob 
Right x Forward = (0,1,0) ist. Ansonsten müssen alle Kreuzprodukte 
vertauscht werden. 

**** DONE Vorgehen
		 CLOSED: [2010-07-28 Wed 21:46]

Im Folgenden seien die Kreuzprodukte mit der _linken_ Hand auszuführen

1. Statt 3 Rotationswinkeln speichert man 3 Vektoren, Forward, Right, Up
2. Anfangs sind diese natürlich auf (0,0,1), (1,0,0) und (0,1,0) eingestellt
3. Bei mouse_x_axis will man um die y-Achse rotieren.
   1. Rotiere Forward um Up. Markiere alle Vektoren außer Forward 
      als ungültig (idealerweise wären Forward und Up noch orthogonal, kann man
      sich aber nicht drauf verlassen), kennzeichne mit *
   2. Right := Up* x Forward, Right steht orthogonal auf Forward und Up*
   3. Up := Forward x Right
4. Bei mouse_y_axis will man um die x-Achse rotieren.
	 1. Rotiere Forward um Right. Wieder alle Vektoren ungültig
	 2. Up := Forward x Right*
	 3. Right := Up x Forward
** TODO Skydome [1/3]
*** DONE Klassischer Ansatz
		 CLOSED: [2010-07-28 Wed 21:47]
**** DONE Vorgehen
		 CLOSED: [2010-07-28 Wed 21:47]

1. Erstelle Vertexbuffer für die _komplette_ Kugel

2. Zeichne diesen Vertexbuffer als Punktprimitiv

3. Schaue wie sich die Winkel auswirken, überlege wie man 
   die Winkel wählen müsste um einen Dome zu bekommen

4. Korrigiere eventuell den Fehler in der perspektivischen 
   oder der Modelviewmatrix

5. Erstelle korrekten Indexbuffer

6. Erstelle Shader, der Anhand der y-Koordinate die Farbe als 
   Gradient von hellblau zu blau wählt. Der Shader braucht 
   dafür vermutlich die maximal y-Koordinate.

*** TODO Icosphere-Ansatz
**** TODO Suche bei Google nach "icosphere triangle strip"
*** TODO Weiteres Vorgehen [5/6]
**** DONE render_height_map mit Kamera fixen
		 CLOSED: [2010-07-29 Thu 01:10]
**** DONE angle-Funktion in fcppt pushen (vorher test mit FCPPT_TEXT versehen)
		 CLOSED: [2010-07-28 Wed 23:40]
**** DONE Sonne einfügen
		 CLOSED: [2010-07-29 Thu 00:50]
**** TODO Maximalwinkel für den Skydome einstellen (nicht immer 90 Grad)
**** DONE Neues Programm render_scene machen und render_height_map aufsplitten
		 CLOSED: [2010-07-29 Thu 00:52]
**** DONE Skydome in render_scene einbauen
		 CLOSED: [2010-07-29 Thu 18:05]

** TODO Wasser [6/8]
*** DONE Variable =water_height= definieren, die per Kommandozeile einstellbar ist
		 CLOSED: [2010-07-30 Fri 00:02]
*** DONE Funktion einbauen, um die Kamera an der Wasser-Ebene zu spiegeln
		 CLOSED: [2010-07-30 Fri 00:02]
Dazu muss getan werden: 
#+BEGIN_SRC emacs-c++-mode
vec3 new_position = cam.position
new_position.y = -cam.position.y + 2*water_height
vec3 target = cam.position + cam.forward
target.y = -target.y + 2*water_height
vec3 forward = target - new_position
// Streng genommen müsste man hier noch forward und right
// orthogonalisieren, kann man sich aber vermutlich 
// sparen
cam.new_axes(forward,cam.right,forward x right);
#+END_SRC

Vorher sollte die aktuelle Kamera (bzw. das Achsentriplet) gespeichert
werden (oder so)
*** DONE Rendertarget
		 CLOSED: [2010-07-30 Fri 00:10]
Definiere (Konsolen-)Funktion, die die Kamera an der Wasser-Ebene
spiegelt, dann rendert und das gerenderte in einer Datei abspeichert,
die man sich dann angucken kann.

Platzhalter für Clippingplanes einbauen. Außerdem die Möglichkeit
offen lassen, das Wasser beim Rendern auszulassen. Am besten bekommt
die Funktion ein Rendercallback, wo man dann =skydome.render()= und
=height_map.render()= einbauen kann.
*** DONE Quad für Wasser einbauen (mit Wassertextur), rendern
		 CLOSED: [2010-07-30 Fri 17:38]
*** DONE Wassershader
		 CLOSED: [2010-07-30 Fri 17:38]
Dieser Shader sollte geladen werden, wenn das Wasserquad gerendert
wird. Er bekommt zwei World-Matrizen und eine Projektionsmatrix. Bei
der einen steht der Betrachter "normal", bei der anderen gespiegelt
unter der Wasseroberfläche (diese Spiegelungsmatrizen kann man aus dem
ersten Renderpass copypasten). Rausschreiben tut er einerseits
=gl_Position = projection * world * position=, damit das Wasserquad an
der richtigen Stelle gezeichnet wird. Andererseits leitet er
=out vec2 texcoord = vec2(projection * mirrored_world * position)=
weiter, die im Fragmentshader als Texturkoordinaten (für die
vorgerenderte Textur) gelten. Alternativ könnte man auch =out vec4
texcoord = projection * mirrored_world * position= versuchen
und dann im Fragmentshader: 
=vec2 texcoord_new = vec2(texcoord.x/texcoord.w,texcoord.y/texcoord.w)=
Der Kerl im Paper macht zusätzlich noch /2 +0.5, vermutlich aus
Normierungsgründen. Das vielleicht auch noch probieren.
*** DONE Clipping in den Shadern machen
		 CLOSED: [2010-08-01 Sun 17:56]
Hierzu braucht der height_map-Shader die Wasserhöhe. Außerdem brauch
er das boolsche Flag, ob er clippen soll. Ist dies true, berechnet er
=position.y - wasserhöhe= und speichert dies in gl_ClipDistance[0].

ACHTUNG: Man muss die 0-te Clippingplane auch noch aktivieren.
*** TODO Ripple-Effekt auf dem Wasser
1. Hierzu muss eine Bump-Textur geladen werden. Hier interessieren
   aber nur die rg-Werte.
2. Diese Bump-Textur wird mit einer Texturskalierung auf das
   Wasserquad gelegt (Konsolenvariable und Kommandozeilenvariable für
   die Skalierung, Kommandozeilenvariable für die Bumptextur, außerdem
   Konsolenfunktion dafür?)
3. Eine Zeitvariable wird eingeführt
4. Es wird nicht mehr die aktuelle Texturkoordinate im Fragmentshader
   genommen sondern die perturbierte. Im Vertexshader: 
	 texcoord_projected = perspective * ...
	 texcoord_bump = bump_coord + time * move_direction
	 Die bump-Textur wird skaliert auf das Quad gelegt, dessen Ursprung
   wird aber mit der move_direction verschoben. Man kann hier die
   Geschwindigkeit der Zeit noch vergrößern damit es schneller gepannt
   wird.
	 Im Fragmentshader:
	 vec4 bump_color = texture(bump_texture,texcoord_bump);
	 vec2 perturbation = wave_height * (bump_color.rg – 0.5); 
	 vec2 perturbed_coords = texcoord_projected + perturbation;
5. Dull-Color wird eingebaut, im Fragmentshader:
	 vec4 dull_color(0.1f, 0.1f, 0.2f, 1.0f);
	 float dull_factor = 0.2;
	 frag_color = mix(real_color,dull_color,dull_factor);
*** TODO Bug in Wassertextur fixen
** TODO Nebel
1. Im Pixelshader:
#+BEGIN_SRC emacs-c++-mode
const float LOG2 = 1.442695;
float z = gl_FragCoord.z / gl_FragCoord.w;
float fogFactor = exp2( -gl_Fog.density * 
				   gl_Fog.density * 
				   z * 
				   z * 
				   LOG2 );
fogFactor = clamp(fogFactor, 0.0, 1.0);

gl_FragColor = mix(gl_Fog.color, finalColor, fogFactor );
#+END_SRC

2. Oder doch lieber im Vertexshader, siehe [[http://www.ozone3d.net/tutorials/glsl_fog/p03.php][hier]]:

	"Fremde" Methode:

	1. Berechne gl_Position, nehme davon die Länge =n= (?)
	2. Berechne: =faktor = exp2(-dichte^2 * n^2 *1.442695)=, clampe
		 zwischen 0 und 1, gebe an PS weiter
	3. Berechne =frag_color = mix(fog_color,final_color,fog_factor)=
	
	"Eigene" Methode:
	
	1. Gebe Augenpunkt als uniform mit.
  2. Berechne Abstand Augenpunkt und aktueller Vertex
	3. Berechne =faktor = exp2(-dichte^2 * abstand^2 *1.442695)=, gebe an PS weiter
	4. Mache dasselbe wie bei der fremden Methode.

** TODO Models (Bäume etc.)
** TODO Shadow Maps

** TODO HDR-Faking für besseres Licht
** TODO Physik, Fahrzeuge

** TODO Wie gehts weiter? Sounds?
** TODO Diverses [4/7]
*** DONE Framecounter einbauen
		 CLOSED: [2010-07-30 Fri 18:24]
*** TODO gizmo_init fixen
*** TODO Average-Filter übers Terrain laufen lassen
*** DONE Skydome-Unterfarbe weiterreichen
		 CLOSED: [2010-07-31 Sat 01:30]
*** DONE fov und aspect an skydome weiterreichen (near und far nicht)
		 CLOSED: [2010-07-31 Sat 01:30]
*** DONE z-Puffer-Artefakte minimieren
		 CLOSED: [2010-07-31 Sat 01:31]
*** TODO Matrixmultiplikationen durch mvp-Matrix ersetzen
*** TODO water_height durch water_level ersetzen
*** TODO water sollte ein rect bekommen statt einen Dimensionwert
Dahinter steckt der Gedanke, dass das Wasser abgeschlossen sein sollte!
*** TODO Kleiner Rewrite der Subsysteme
Die Subsysteme sollten abgeschlossener sein und somit selber mit der
Konsole und der Kommandozeile kommunizieren.

Jedes Subsystem sollte eine Klasse haben, das einen Vermittler
zwischen Konsole und Subsystem darstellt (es sollte also beide im
Konstruktor bekommen). Diese Klasse registriert sich die Callbacks und
steuert deren Ausführung.

Jedes Subsystem eine Funktion bereitstellen, die eine
options_description zurückliefert. Außerdem sollte eine
factory-Methode bereitgestellt werden, die die options_description
bekommt und ggf. zusätzliche Parameter und daraus ein Objekt erstellt.
Dazu hift Nebel, sowie eine Near-Plane, die weiter weg ist und eine
Far-Plane, die näher dran ist.
