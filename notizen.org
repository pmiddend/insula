* Notizen

** Foliage

	- Hat keinen assoziierten Body? Muss aber ins Frustum Culling
    aufgenommen werden. Neue Klasse =foliage=, von =physics::object=
    abgeleitet. Diese erstellt einen =btBroadphaseProxy= (mit
    entsprechender =shape=). Sie erstellt danach ein
    =btCollisionObject= und setzt dort den =userPointer= auf
    =this=. Das =m_clientObject= vom btBroadphaseProxy wird auf das
    =btCollisionObject= gesetzt. So kann die Logik in
    =physics::culler::Process= genauso laufen wie bei Nichtfoliages.
	- Damit das Ding trotzdem mit nichts kollidiert: von
    =btOverlapFilterCallback= ableiten. Das kriegt zwei
    Broadphaseproxies, die kann man beide in =physics::object= casten
    und gucken, ob eins von denen 'ne =foliage= ist. Dann false
    zurückgeben. Wenn beides =physics::static_model= sind, kann man
    auch false zurückgeben, aber das bringt vermutlich nichts.
	- Im =prop::manager= fügt man =blueprint= noch ein =foliage=-Flag
    hinzu. Bei =instantiate= wird nun eine Liste von =scene::instance=
    zurückgegeben und man muss ein =foliage_instance= schreiben
    (copypaste von =static_model_instance=)

** =physics::world/physics::object=

	 - =physics::object= bekommt =object_type::type= enum spendiert,
     sodass man einfach prüfen kann, von welchem Typ ein Physikobjekt
     ist. Typen sind hier: 
		   - foliage
			 - nugget
			 - prop
			 - vehicle
		 Beim Erstellen von =physics::static_model= muss das natürlich im
     Konstruktor weitergeleitet werden an den Konstruktor von
     =physics::object=.
	 - Man kann sich dann bei der Physik registrieren via:
		 =register_collision(object_type::type,object_type::type)=
		 Im Prinzip muss man dann für jede mögliche Kollision zwischen
     Objekten ein Signal deklarieren. Aber erstmal reicht ja zwischen
     Vehikel und Nugget. Das Callback sieht aber generisch aus, man
     bekommt =(physics::object,physics::object)=

** =nugget::manager=
	- Bekommt seine Einstellungen aus globaler Konfigurationsdatei
    (bekommt ein =json::object=)
		- =model=
		- =texture=
		- =flatness_range=
		- =floating_height=
		- =count=
	- Es gibt genau ein =model::backend=.
	- Es gibt eine =blueprint=-Klasse, die enthält aber nur die Position
    als =vec3=
	- Es gibt statt =instantiate= ein =create_instance=, was eine
    Instanz erzeugt und als =auto_ptr= zurückliefert.
	- Die Instanz bekommt die =instance_sequence= im Konstruktor. Sie
    hat eine Methode =update()=, was den Winkel der Props verändert
    (man kann sich aus dem =static_model= die Position holen und den
    Winkel kann man global Speichern)
	- Das Ding registriert sich bei der =physics::world= für Kollisionen
    zwischen Nugget und Vehikel und löscht dann Props entsprechend und
    spielt einen Ton ab.

** Anderes
	- Terrain und Skydome sollten in den Szenemanager eingebaut werden
	- Dazu muss jedem Backend eine Priorität zugeordnet werden (Datenfeld in backend)
	- Es gibt eine globale Prioritäts-enum (=scene/priorities=)
	- In =render()= von scene wird ein =set<backend,priority_sorter>=
		konstruiert und danach die Backends abgearbeitet
	- Das Terrain ist Backend und Instance gleichzeitig, genau wie der
		Skydome und das Wasser (geht das überhaupt?) und sie fügen sich
		selber in den Szenemanager ein.


* Links
- Zwei Fixes für raycastvehicle: http://www.bulletphysics.org/Bullet/phpBB3/viewtopic.php?f=9&t=2047&hilit=rolling+friction
- Frustum/Occlusion culling: http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?f=9&t=3896
- Vehicles in Bullet
- http://vdrift.net/Forum/viewtopic.php?p=10332&sid=ce7581e8f6c9da3b93eec41440a4d776
- Shadow Mapping: http://www.fabiensanglard.net/shadowmapping/index.php
- Viele Paper: http://nis-lab.is.s.u-tokyo.ac.jp/~nis//abs_cgi.html#pas95
* Ideen für später
** TODO Terrain zufallsgenerieren
** TODO Farben statt Texturen bei Höhenfeld verwenden
Motivation hierzu: [[http://simblob.blogspot.com/2010/09/polygon-map-generation-part-1.html][von hier]]
** TODO LOD für Models
** TODO Pfeil einbauen, der die Richtung weist
Dieser Pfeil könnte z.B. in die "durchschnittliche" Richtung zeigen,
wo noch viele Nuggets zu finden sind.
** TODO Terrainvereinfachung
Hierzu z.B. cgal
* Kleinere Sachen
** DONE cout/cerr zu Konsole weiterleiten
	 CLOSED: [2010-09-11 Sat 01:01]
** TODO foldl in gameover durch accumulate ersetzen
** TODO height_map/calculate_point etc. dokumentieren und ggf. verbessern
** TODO gizmo in math verfrachten
** TODO orthonormalize_gram_schmidt hinzufügen und gucken wie's läuft
** TODO machine::input_repeat_callback fixen
** TODO Präfixe in config.json auf Sektionen in json abbilden
* Aktivitäten
** TODO Shadow Maps [1/5]
*** DONE Neues uniform-System aufsetzen
		 CLOSED: [2010-09-05 Sun 14:44]
*** TODO Teste orthografische Projektion aus Sicht der Sonne
*** TODO Setze das Rendern der Shadowmap auf
- Hierzu muss orthografisch projiziert werden aus sich der Sonne
  (Position?)
- Der Vertexshader sollte nur projizieren
- Der Fragmentshader sollte nur einen float rausschreiben, die Tiefe
  des Fragments
- Die Szene muss in eine Textur gerendert werden
*** TODO Per Kommandozeile die Tiefentextur in eine Datei schreiben
*** TODO Den eigentlichen Tiefenalgorithmus implementieren


- Der Heightmap-Vertexshader brauch dazu die mvp-Matrix des Lichtrenderns.
- Für jeden Vertex v werden zwei Größen berechnet: 
	1. vl = mvp_light * v
	2. vp = mvp * v
- Gib vp und vl an den Fragmentshader weiter
- Berechne aus vl die Texturkoordinate in der Shadowmap (selbe Technik
  wie beim Wasser)
- Vergleiche den z-Wert von vp mit dem z-Wert in der Shadowmap, setze
  entsprechend die Pixel
** TODO Diffuses Modelshading
** TODO Neues Fontsystem
Ziele:

Man will Farben und Stile (fett, kursiv etc.) unterbringen sowie
verschiedene Größen, das alles steuerbar mit einer kleinen DSEL etwa
wie folgt:

#+begin_src c++
draw_text(
  font_collection,
	size(15) >> color(black) >> "foo" >> (bold >> "bar") 
    >> italics >> size(20) >> "baz");
#+end_src

Man muss sich hier implizit auf ttf beschränken, weil andere
Fontformate vermutlich bold/italics etc. anders modellieren. Eine
=font_collection= muss eine Sammlung von geladenen ttf-Fonts sein
ausgesucht nach:

- Größe
- Stil

In etwa so:

#+begin_src c++
font_collection fonts(
  // Normal
  "default.ttf",
	// Bold
  optional<string>(),
	// Italics,
	"default_it.ttf",
	make_container<size_container>(15)(20)(25));
#+end_src
** TODO graphics::stats erweitern
Man könnte die Stats verallgemeinern: Ein "stat" ist eine textuelle
Informationseinheit (z.B. Geschwindigkeit des Vehikels), die scoped
beim "stats"-Objekt eingetragen werden kann. Details muss man sich
noch überlegen.
** TODO Musiklautstärke muss einstellbar sein
** TODO Mehr Musik
** TODO Konkretes Level bauen, was man auch ausliefern kann
** TODO Nuggets aus game_inner rausziehen
** TODO "Nugget-Indikatoren" einbauen
** TODO Persistente Konsolenhistory
** TODO Partikelsystem
** TODO random_point erweitern
Die Funktion sollte eine =steepness_range= bekommen (also ein
Intervall in $[0,1]$) und generiert dann mit Hilfe des normalisierten
Gradienten einen Punkt mit dieser Steilheit. Dei Funktion brauch dazu
den normalisierten Gradienten, d.h. =height_map= muss den zur
Verfügung stellen)
** TODO Looping von Musik fixen
Man kann bei Streamingsounds loop einstellen, das funzt aber nicht richtig
** DONE vehicle::speed_kmh muss relativ zu forward sein
	 CLOSED: [2010-09-12 Sun 20:10]
** DONE Auto-Culling fixen
	 CLOSED: [2010-09-12 Sun 20:10]
** DONE Autosound wird nicht moduliert
	 CLOSED: [2010-09-12 Sun 20:10]
** DONE Auto in scene::manager integrieren
	 CLOSED: [2010-09-12 Sun 20:09]
** DONE Alpha-Blending
	 CLOSED: [2010-09-12 Sun 15:38]
- Bisheriges Alphablending fixen, damit klar ist, wie man
  Alphablending prinzipiell umsetzt.
- Auf binäres Alphablending umsteigen.
** DONE Approximationen erweitern
	 CLOSED: [2010-09-12 Sun 01:36]
Es kommt noch approximation::exact hinzu, sowie cylinder_x, cylinder_y
und cylinder_z. exact bekommt ein model::object_ptr
** DONE config.po wegmachen
	 CLOSED: [2010-09-11 Sat 20:52]
In config.json Sektion "command-line", in der nur String-Optionen
reinkommen, po-Parser kopieren
** DONE Textur tst spiegelverkehrt
		 CLOSED: [2010-09-09 Thu 23:18]
