* Neues Konzept

Objekte und Eigenschaften:

- Models
	- Normale mvp-Matrix der Kamera
	- Entweder
		- Normalmatrix
	- Alternativ
		- Shadowmap
		- Shadow-mvp
	- Eine Textur
	- Doublesideculling
- Skydome 
	- Rotationsmatrix der Kamera
	- Eigene Projektion (near und far müssen angepasst werden)
	- Frontculling, Depthbuffer aus
	- Muss zuerst gezeichnet werden
	- Keine Textur
- Terrain
	- Normale mvp-Matrix der Kamera
	- Mehrere Texturen
	- Shadowmap
- Partikel
	- Normale mvp-Matrix der Kamera
	- Alphablending
	- Eine Textur
- Wasser
	- Normale mvp-Matrix der Kamera
	- Spiegel-mvp
	- Eine Textur

Anforderungen:

1. Das Terrain und der Skydome (und ggf. noch andere Komponenten)
   werden aus der Unterwassersicht in das Wassertarget gerendert
   (dabei muss bei einigen Komponenten das Culling korrigiert werden
   und die Heightmap muss Clipping aktivieren)
2. Alle statischen Komponenten werden mit einem Shadow-Shader in die
   Shadowmap gerendert (dabei muss das Culling angepasst werden).
3. Alle Komponenten werden in den Framebuffer gerendert
4. Der Framebuffer wird mit einem PP-Filter als Quad gerendert (das
   ist unabhängig von allem vorhergehenden)
5. Das "Overlay" wird gerendert, d.h. die Schrift, die Konsole, usw.

Ideen:

- Klasse =scene::backend= hat die Methoden =begin/end=. Diese bekommen
  jetzt ein Argument =pass= was den Renderpass angibt (=normal=,
  =water=, =shadow=). Die können daraufhin den entsprechenden Shader
  laden und die richtigen Flags setzen.
- Ein Backend benötigt einen =int=, der seine Priorität angibt. So
  kann man erzwingen, dass der Skydome als erstes gerendert wird.
- Ein Backend kann auch einen Namen kriegen, damit man es einfacher
  deaktivieren kann.
- Ein Backend kann deaktiviert werden und wird dann übergangen.
- Eine Instance kann auch deaktiviert werden und wird dann übergangen.
- Ein *Pass* könnte jetzt eine Funktion sein, die bestimmte
  Backends/Instanzen deaktiviert und danach
  =scene::manager::render(pass)= aufruft. Oder eine Klasse mit begin/end

- Wasser-Pass: 
	- Deaktiviere Wasserbackend
	- Ggf. deaktiviere Modelbackend
	- Setze Target auf interne Textur
	- Setze Unterwasserkamera
	- =scene::render(passes::water)=
		- Die Heightmap setzt Clippingplane und wechselt das Culling (zu
      =both=)
		- Skydome reagiert nicht darauf und rendert sich ganz normal
		- Alles andere ist deaktiviert (Models könnten auch gezeichnet werden)
- Shadow-Pass:
	- Deaktiviere ggf. Nuggets (einzeln?)
	- Setze Target auf Shadowtextur
	- Setze Sonnenkamera, Projektion auf Orthogonal?
	- =scene::render(passes::shadow)=
		- Terrain setzt Shadowshader

Probleme:
- Wie behandelt man die beiden Shader "normal" und "shadow"? Simple
  Lösung: Jedes Backend erstellt zwei Shader. Aber dann müsste man den
  kompletten "Prelude" zweimal erstellen mit Variablen und Samplern.

* Vorgehen
- Shadowmaps einbauen. Auf die Weise spart man es sich vielleicht,
  sich über die zentrale Speicherstelle für die Beleuchtungsvariablen
  zu kümmern.
- Gucken ob Shadowmaps jedes Frame generiert werden können. Falls
  nein, über Blob Shadows informieren.
- Nebel einbauen
- Postprocessingeffekt einbauen - aber nur zum Test. Wenn's nicht gut
  aussieht, wieder wegnehmen.
- Terrain-Autogenerierung oder einfach Ersetzung der Texturen durch
  Farben angehen
* Links
- Zwei Fixes für raycastvehicle: http://www.bulletphysics.org/Bullet/phpBB3/viewtopic.php?f=9&t=2047&hilit=rolling+friction
- Frustum/Occlusion culling: http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?f=9&t=3896
- Vehicles in Bullet
- http://vdrift.net/Forum/viewtopic.php?p=10332&sid=ce7581e8f6c9da3b93eec41440a4d776
- Shadow Mapping: http://www.fabiensanglard.net/shadowmapping/index.php
- Viele Paper: http://nis-lab.is.s.u-tokyo.ac.jp/~nis//abs_cgi.html#pas95
- Besserer Charactercontroller: http://code.google.com/p/bullet/issues/detail?id=198
- Weiterer CC: http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?f=9&t=5712
- Landschaftsgenerierung http://www.dungeonleague.com/page/2/
- Neue AA-Methode: http://www.gamedev.net/community/forums/topic.asp?topic_id=580517
* Ideen für später
** TODO Terrain zufallsgenerieren
** TODO Farben statt Texturen bei Höhenfeld verwenden
Motivation hierzu: [[http://simblob.blogspot.com/2010/09/polygon-map-generation-part-1.html][von hier]]
** TODO LOD für Models
** TODO Steuerung konfigurierbar machen
** TODO Terrainvereinfachung
Hierzu z.B. cgal
* Kleinere Sachen
** TODO gizmo in math verfrachten
** TODO orthonormalize_gram_schmidt hinzufügen und gucken wie's läuft
** TODO machine::input_repeat_callback fixen
** TODO fcppt::assign durch initializer_list ersetzen
** TODO height_map und water mit parameters-Klassen ausstatten
** TODO Die Nuggets sollten sich schön drehen
** TODO scene von intrusive auf was besseres umstellen
Eine instance trägt sich selber ein und aus und kriegt das Backend im
Konstruktor.
** TODO =camera::perspective= in =camera::projection= umbenennen
** DONE Präfixe in config.json auf Sektionen in json abbilden
	 CLOSED: [2010-10-03 Sun 18:31]
** DONE foldl in gameover durch accumulate ersetzen
	 CLOSED: [2010-10-03 Sun 18:29]
** DONE cout/cerr zu Konsole weiterleiten
	 CLOSED: [2010-09-11 Sat 01:01]
** DONE height_map/calculate_point etc. dokumentieren und ggf. verbessern
	 CLOSED: [2010-10-02 Sat 18:36]
** DONE Die Kamera fixen
	 CLOSED: [2010-10-02 Sat 16:52]
Eine Egoshooterkamera funktioniert so: wenn die Maus auf der x-Achse
bewegt wird, werden alle drei Gizmovektoren um $(0,1,0)$ gedreht
* Aktivitäten
** TODO Shadow Maps [1/5]
*** DONE Neues uniform-System aufsetzen
		 CLOSED: [2010-09-05 Sun 14:44]
*** TODO Teste orthografische Projektion aus Sicht der Sonne
*** TODO Setze das Rendern der Shadowmap auf
- Hierzu muss orthografisch projiziert werden aus sich der Sonne
  (Position?)
- Der Vertexshader sollte nur projizieren
- Der Fragmentshader sollte nur einen float rausschreiben, die Tiefe
  des Fragments
- Die Szene muss in eine Textur gerendert werden
*** TODO Per Kommandozeile die Tiefentextur in eine Datei schreiben
*** TODO Den eigentlichen Tiefenalgorithmus implementieren


- Der Heightmap-Vertexshader brauch dazu die mvp-Matrix des Lichtrenderns.
- Für jeden Vertex v werden zwei Größen berechnet: 
	1. vl = mvp_light * v
	2. vp = mvp * v
- Gib vp und vl an den Fragmentshader weiter
- Berechne aus vl die Texturkoordinate in der Shadowmap (selbe Technik
  wie beim Wasser)
- Vergleiche den z-Wert von vp mit dem z-Wert in der Shadowmap, setze
  entsprechend die Pixel
** TODO Neues Fontsystem
Ziele:

Man will Farben und Stile (fett, kursiv etc.) unterbringen sowie
verschiedene Größen, das alles steuerbar mit einer kleinen DSEL etwa
wie folgt:

#+begin_src c++
draw_text(
  font_collection,
	size(15) >> color(black) >> "foo" >> (bold >> "bar") 
    >> italics >> size(20) >> "baz");
#+end_src

Man muss sich hier implizit auf ttf beschränken, weil andere
Fontformate vermutlich bold/italics etc. anders modellieren. Eine
=font_collection= muss eine Sammlung von geladenen ttf-Fonts sein
ausgesucht nach:

- Größe
- Stil

In etwa so:

#+begin_src c++
font_collection fonts(
  // Normal
  "default.ttf",
	// Bold
  optional<string>(),
	// Italics,
	"default_it.ttf",
	make_container<size_container>(15)(20)(25));
#+end_src
** TODO graphics::stats erweitern
Man könnte die Stats verallgemeinern: Ein "stat" ist eine textuelle
Informationseinheit (z.B. Geschwindigkeit des Vehikels), die scoped
beim "stats"-Objekt eingetragen werden kann. Details muss man sich
noch überlegen.
** TODO Mehr Musik
** TODO Persistente Konsolenhistory
** TODO Partikelsystem
** TODO Props/Ghosts sollen sich Normale anpassen können
** TODO cli_options weitestgehend loswerden
Das meiste kann durch json ersetzt werden
** TODO Looping von Musik fixen
Man kann bei Streamingsounds loop einstellen, das funzt aber nicht richtig
** DONE Diffuses Modelshading
	 CLOSED: [2010-10-02 Sat 18:34]
** DONE Musiklautstärke muss einstellbar sein
	 CLOSED: [2010-10-02 Sat 18:34]
** DONE Nuggets aus game_inner rausziehen
	 CLOSED: [2010-09-17 Fri 19:40]
** DONE "Nugget-Indikatoren" einbauen
	 CLOSED: [2010-09-17 Fri 19:40]
** DONE random_point erweitern
	 CLOSED: [2010-09-17 Fri 19:40]
Die Funktion sollte eine =steepness_range= bekommen (also ein
Intervall in $[0,1]$) und generiert dann mit Hilfe des normalisierten
Gradienten einen Punkt mit dieser Steilheit. Dei Funktion brauch dazu
den normalisierten Gradienten, d.h. =height_map= muss den zur
Verfügung stellen)
** DONE vehicle::speed_kmh muss relativ zu forward sein
	 CLOSED: [2010-09-12 Sun 20:10]
** DONE Auto-Culling fixen
	 CLOSED: [2010-09-12 Sun 20:10]
** DONE Autosound wird nicht moduliert
	 CLOSED: [2010-09-12 Sun 20:10]
** DONE Auto in scene::manager integrieren
	 CLOSED: [2010-09-12 Sun 20:09]
** DONE Alpha-Blending
	 CLOSED: [2010-09-12 Sun 15:38]
- Bisheriges Alphablending fixen, damit klar ist, wie man
  Alphablending prinzipiell umsetzt.
- Auf binäres Alphablending umsteigen.
** DONE Approximationen erweitern
	 CLOSED: [2010-09-12 Sun 01:36]
Es kommt noch approximation::exact hinzu, sowie cylinder_x, cylinder_y
und cylinder_z. exact bekommt ein model::object_ptr
** DONE config.po wegmachen
	 CLOSED: [2010-09-11 Sat 20:52]
In config.json Sektion "command-line", in der nur String-Optionen
reinkommen, po-Parser kopieren
** DONE Textur tst spiegelverkehrt
		 CLOSED: [2010-09-09 Thu 23:18]
